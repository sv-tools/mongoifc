# mongoifc

[![Code Analysis](https://github.com/sv-tools/mongoifc/actions/workflows/checks.yaml/badge.svg)](https://github.com/sv-tools/mongoifc/actions/workflows/checks.yaml)
[![Go Reference](https://pkg.go.dev/badge/github.com/sv-tools/mongoifc.svg)](https://pkg.go.dev/github.com/sv-tools/mongoifc)
[![codecov](https://codecov.io/gh/sv-tools/mongoifc/branch/main/graph/badge.svg?token=0XVOTDR1CW)](https://codecov.io/gh/sv-tools/mongoifc)
[![GitHub tag (latest SemVer)](https://img.shields.io/github/v/tag/sv-tools/mongoifc?style=flat)](https://github.com/sv-tools/mongoifc/releases)

The Interfaces for the MongoDB driver

## Versioning Policy

The `mongoifc` code is stabilized, so now the version will match the version of the MongoDB driver since `v1.8.0`.

In case of need for bug fixes in `mongoifc`, the version will be in this format `v1.8.1+N`, where `v1.8.1` is the version of MongoDB driver and `N` is a patch of `mongoifc`. 
The new version for changes in README.md, tests, examples, GitHub workflows is not required.

## :bangbang: **Important**

It is not a simple drop in replacement because of the limitations in Go.
You should rewrite your code to use this library instead of mongo driver.
```go
conn := mongoifc.Connect(...)
```
instead of
```go
conn := mongo.Connect(...)
```

or if you have a special code that returns the mongo client then you need to wrap it:
```go
orig := mongo.Connect(...)

...

conn := mongoifc.WrapClient(orig)
```

Now let's dig a bit into the limitations. Let's assume you have the function that returns admin users,
and you rewrote it to use `mongoifc`:
```go
func GetAdmins(ctx context.Context, db mongoifc.Database) ([]*User, error) {
	var users []*User
	cur, err := db.Collection(UsersCollection).Find(ctx, User{
		Active: true,
		IsAdmin: true,
	})
	if err != nil {
		return nil, err
	}
	if err := cur.All(ctx, &users); err != nil {
		return nil, err
	}
	return users, err
}
```
and if you pass an object of `*mongo.Database` type instead of `mongoifc.Database`
```go
conn, _ := mongo.Connect(context.Background(), ...)
db := conn.Database(...)

GetAdmins(context.Background(), db)
```
then compilation fails with such error:

     cannot use db (type *mongo.Database) as type mongoifc.Database in argument to simple.GetAdmins:
         *mongo.Database does not implement mongoifc.Database (wrong type for Aggregate method)
             have Aggregate(context.Context, interface {}, ...*"go.mongodb.org/mongo-driver/mongo/options".AggregateOptions) (*mongo.Cursor, error)
             want Aggregate(context.Context, interface {}, ...*"go.mongodb.org/mongo-driver/mongo/options".AggregateOptions) (mongoifc.Cursor, error)

## Wrapped Interfaces

- [x] Client: https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Client
- [x] Database: https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Database
- [x] Session: https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Session
- [x] ChangeStream: https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#ChangeStream
- [x] Cursor: https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Cursor
- [x] Collection: https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#Collection
- [x] SingleResult: https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#SingleResult
- [x] IndexView: https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#IndexView
- [x] SessionContext: https://pkg.go.dev/go.mongodb.org/mongo-driver/mongo#SessionContext

## Mocks

The `mocks` folder contains the mocks generated by [mockery](https://github.com/vektra/mockery) and [gomock](https://github.com/golang/mock) tools.

The examples of how to use the mocks can be found in the `examples` folder or check any of the `*_test.go` files as well. 

## Example

Here you can find the examples of how to use and mock mongodb functions

```go
package main

import (
	"context"
	"encoding/json"
	"os"

	"go.mongodb.org/mongo-driver/bson/primitive"
	"go.mongodb.org/mongo-driver/mongo/options"

	"github.com/sv-tools/mongoifc"
)

const (
	UsersCollection = "users"
)

type User struct {
	ID string `json:"id,omitempty" bson:"_id,omitempty"`
	Name string `json:"name,omitempty" bson:"name,omitempty"`
	Email string `json:"email,omitempty" bson:"email,omitempty"`
	Active bool `json:"active,omitempty" bson:"active,omitempty"`
	IsAdmin bool `json:"is_admin,omitempty" bson:"is_admin,omitempty"`
}

func GetAdmins(ctx context.Context, db mongoifc.Database) ([]*User, error) {
	var users []*User
	cur, err := db.Collection(UsersCollection).Find(ctx, User{
		Active: true,
		IsAdmin: true,
	})
	if err != nil {
		return nil, err
	}
	if err := cur.All(ctx, &users); err != nil {
		return nil, err
	}
	return users, err
}

// go run main.go "mongodb://${MONGO_USERNAME}:${MONGO_PASSWORD}@${MONGO_HOST}:${MONGO_PORT}/?authSource=admin" "${DATABASE}"
func main() {
	uri, database := os.Args[1], os.Args[2]
	opt := options.Client().ApplyURI(uri)
	cl, err := mongoifc.NewClient(opt)
	if err != nil {
		panic(err)
	}

	if err = cl.Connect(context.Background()); err != nil {
		panic(err)
	}
	defer cl.Disconnect(context.Background())

	db := cl.Database(database)
	users, err := GetAdmins(context.Background(), db)
	if err != nil {
		panic(err)
	}
	enc := json.NewEncoder(os.Stdout)
	enc.SetIndent("", "  ")
	if err := enc.Encode(users); err != nil {
		panic(err)
	}
}
```

### How to mock

```go
package main

import (
	"context"
	"testing"

	"github.com/golang/mock/gomock"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"go.mongodb.org/mongo-driver/mongo/options"

	"github.com/sv-tools/mongoifc"
	gomockMocks "github.com/sv-tools/mongoifc/mocks/gomock"
	mockeryMocks "github.com/sv-tools/mongoifc/mocks/mockery"
)

func TestGetAdmins(t *testing.T) {
	t.Parallel()

	expectedUsers := []*User{
		{Name: "foo", Active: true, IsAdmin: true},
		{Name: "bar", Active: true, IsAdmin: true},
	}
	ctx := context.Background()

	t.Run("mockery", func(t *testing.T) {
		t.Parallel()

		cur := &mockeryMocks.Cursor{}
		cur.On("All", ctx, mock.Anything).Run(func(args mock.Arguments) {
			users := args[1].(*[]*User)
			*users = append(*users, expectedUsers...)
		}).Return(nil)

		col := &mockeryMocks.Collection{}
		col.On("Find", ctx, mock.AnythingOfType("User")).Return(cur, nil)

		db := &mockeryMocks.Database{}
		db.On("Collection", UsersCollection).Return(col)

		users, err := GetAdmins(ctx, db)
		require.NoError(t, err)
		require.Equal(t, expectedUsers, users)
	})

	t.Run("gomock", func(t *testing.T) {
		t.Parallel()

		ctrl := gomock.NewController(t)
		defer ctrl.Finish()

		cur := gomockMocks.NewMockCursor(ctrl)
		cur.EXPECT().All(ctx, gomock.Any()).Do(func(ctx context.Context, arg interface{}) {
			users := arg.(*[]*User)
			*users = append(*users, expectedUsers...)
		}).Return(nil)

		col := gomockMocks.NewMockCollection(ctrl)
		col.EXPECT().Find(ctx, gomock.Any()).Return(cur, nil)

		db := gomockMocks.NewMockDatabase(ctrl)
		db.EXPECT().Collection(UsersCollection).Return(col)

		users, err := GetAdmins(ctx, db)
		require.NoError(t, err)
		require.Equal(t, expectedUsers, users)
	})
}
```
