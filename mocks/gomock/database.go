// Code generated by MockGen. DO NOT EDIT.
// Source: ./database.go

// Package mocks is a generated GoMock package.
package mocks

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
	mongoifc "github.com/sv-tools/mongoifc"
	mongo "go.mongodb.org/mongo-driver/mongo"
	options "go.mongodb.org/mongo-driver/mongo/options"
	readconcern "go.mongodb.org/mongo-driver/mongo/readconcern"
	readpref "go.mongodb.org/mongo-driver/mongo/readpref"
	writeconcern "go.mongodb.org/mongo-driver/mongo/writeconcern"
)

// MockDatabase is a mock of Database interface.
type MockDatabase struct {
	ctrl     *gomock.Controller
	recorder *MockDatabaseMockRecorder
}

// MockDatabaseMockRecorder is the mock recorder for MockDatabase.
type MockDatabaseMockRecorder struct {
	mock *MockDatabase
}

// NewMockDatabase creates a new mock instance.
func NewMockDatabase(ctrl *gomock.Controller) *MockDatabase {
	mock := &MockDatabase{ctrl: ctrl}
	mock.recorder = &MockDatabaseMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockDatabase) EXPECT() *MockDatabaseMockRecorder {
	return m.recorder
}

// Aggregate mocks base method.
func (m *MockDatabase) Aggregate(ctx context.Context, pipeline interface{}, opts ...*options.AggregateOptions) (mongoifc.Cursor, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, pipeline}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Aggregate", varargs...)
	ret0, _ := ret[0].(mongoifc.Cursor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Aggregate indicates an expected call of Aggregate.
func (mr *MockDatabaseMockRecorder) Aggregate(ctx, pipeline interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, pipeline}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Aggregate", reflect.TypeOf((*MockDatabase)(nil).Aggregate), varargs...)
}

// Client mocks base method.
func (m *MockDatabase) Client() mongoifc.Client {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Client")
	ret0, _ := ret[0].(mongoifc.Client)
	return ret0
}

// Client indicates an expected call of Client.
func (mr *MockDatabaseMockRecorder) Client() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Client", reflect.TypeOf((*MockDatabase)(nil).Client))
}

// Collection mocks base method.
func (m *MockDatabase) Collection(name string, opts ...*options.CollectionOptions) mongoifc.Collection {
	m.ctrl.T.Helper()
	varargs := []interface{}{name}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Collection", varargs...)
	ret0, _ := ret[0].(mongoifc.Collection)
	return ret0
}

// Collection indicates an expected call of Collection.
func (mr *MockDatabaseMockRecorder) Collection(name interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{name}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Collection", reflect.TypeOf((*MockDatabase)(nil).Collection), varargs...)
}

// CreateCollection mocks base method.
func (m *MockDatabase) CreateCollection(ctx context.Context, name string, opts ...*options.CreateCollectionOptions) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, name}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateCollection", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateCollection indicates an expected call of CreateCollection.
func (mr *MockDatabaseMockRecorder) CreateCollection(ctx, name interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, name}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateCollection", reflect.TypeOf((*MockDatabase)(nil).CreateCollection), varargs...)
}

// CreateView mocks base method.
func (m *MockDatabase) CreateView(ctx context.Context, viewName, viewOn string, pipeline interface{}, opts ...*options.CreateViewOptions) error {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, viewName, viewOn, pipeline}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "CreateView", varargs...)
	ret0, _ := ret[0].(error)
	return ret0
}

// CreateView indicates an expected call of CreateView.
func (mr *MockDatabaseMockRecorder) CreateView(ctx, viewName, viewOn, pipeline interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, viewName, viewOn, pipeline}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "CreateView", reflect.TypeOf((*MockDatabase)(nil).CreateView), varargs...)
}

// Drop mocks base method.
func (m *MockDatabase) Drop(ctx context.Context) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Drop", ctx)
	ret0, _ := ret[0].(error)
	return ret0
}

// Drop indicates an expected call of Drop.
func (mr *MockDatabaseMockRecorder) Drop(ctx interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Drop", reflect.TypeOf((*MockDatabase)(nil).Drop), ctx)
}

// ListCollectionNames mocks base method.
func (m *MockDatabase) ListCollectionNames(ctx context.Context, filter interface{}, opts ...*options.ListCollectionsOptions) ([]string, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, filter}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListCollectionNames", varargs...)
	ret0, _ := ret[0].([]string)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCollectionNames indicates an expected call of ListCollectionNames.
func (mr *MockDatabaseMockRecorder) ListCollectionNames(ctx, filter interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, filter}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCollectionNames", reflect.TypeOf((*MockDatabase)(nil).ListCollectionNames), varargs...)
}

// ListCollectionSpecifications mocks base method.
func (m *MockDatabase) ListCollectionSpecifications(ctx context.Context, filter interface{}, opts ...*options.ListCollectionsOptions) ([]*mongo.CollectionSpecification, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, filter}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListCollectionSpecifications", varargs...)
	ret0, _ := ret[0].([]*mongo.CollectionSpecification)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCollectionSpecifications indicates an expected call of ListCollectionSpecifications.
func (mr *MockDatabaseMockRecorder) ListCollectionSpecifications(ctx, filter interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, filter}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCollectionSpecifications", reflect.TypeOf((*MockDatabase)(nil).ListCollectionSpecifications), varargs...)
}

// ListCollections mocks base method.
func (m *MockDatabase) ListCollections(ctx context.Context, filter interface{}, opts ...*options.ListCollectionsOptions) (mongoifc.Cursor, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, filter}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "ListCollections", varargs...)
	ret0, _ := ret[0].(mongoifc.Cursor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ListCollections indicates an expected call of ListCollections.
func (mr *MockDatabaseMockRecorder) ListCollections(ctx, filter interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, filter}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ListCollections", reflect.TypeOf((*MockDatabase)(nil).ListCollections), varargs...)
}

// Name mocks base method.
func (m *MockDatabase) Name() string {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Name")
	ret0, _ := ret[0].(string)
	return ret0
}

// Name indicates an expected call of Name.
func (mr *MockDatabaseMockRecorder) Name() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Name", reflect.TypeOf((*MockDatabase)(nil).Name))
}

// ReadConcern mocks base method.
func (m *MockDatabase) ReadConcern() *readconcern.ReadConcern {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadConcern")
	ret0, _ := ret[0].(*readconcern.ReadConcern)
	return ret0
}

// ReadConcern indicates an expected call of ReadConcern.
func (mr *MockDatabaseMockRecorder) ReadConcern() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadConcern", reflect.TypeOf((*MockDatabase)(nil).ReadConcern))
}

// ReadPreference mocks base method.
func (m *MockDatabase) ReadPreference() *readpref.ReadPref {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ReadPreference")
	ret0, _ := ret[0].(*readpref.ReadPref)
	return ret0
}

// ReadPreference indicates an expected call of ReadPreference.
func (mr *MockDatabaseMockRecorder) ReadPreference() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ReadPreference", reflect.TypeOf((*MockDatabase)(nil).ReadPreference))
}

// RunCommand mocks base method.
func (m *MockDatabase) RunCommand(ctx context.Context, runCommand interface{}, opts ...*options.RunCmdOptions) mongoifc.SingleResult {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, runCommand}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RunCommand", varargs...)
	ret0, _ := ret[0].(mongoifc.SingleResult)
	return ret0
}

// RunCommand indicates an expected call of RunCommand.
func (mr *MockDatabaseMockRecorder) RunCommand(ctx, runCommand interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, runCommand}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunCommand", reflect.TypeOf((*MockDatabase)(nil).RunCommand), varargs...)
}

// RunCommandCursor mocks base method.
func (m *MockDatabase) RunCommandCursor(ctx context.Context, runCommand interface{}, opts ...*options.RunCmdOptions) (mongoifc.Cursor, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, runCommand}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "RunCommandCursor", varargs...)
	ret0, _ := ret[0].(mongoifc.Cursor)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// RunCommandCursor indicates an expected call of RunCommandCursor.
func (mr *MockDatabaseMockRecorder) RunCommandCursor(ctx, runCommand interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, runCommand}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RunCommandCursor", reflect.TypeOf((*MockDatabase)(nil).RunCommandCursor), varargs...)
}

// Watch mocks base method.
func (m *MockDatabase) Watch(ctx context.Context, pipeline interface{}, opts ...*options.ChangeStreamOptions) (mongoifc.ChangeStream, error) {
	m.ctrl.T.Helper()
	varargs := []interface{}{ctx, pipeline}
	for _, a := range opts {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "Watch", varargs...)
	ret0, _ := ret[0].(mongoifc.ChangeStream)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Watch indicates an expected call of Watch.
func (mr *MockDatabaseMockRecorder) Watch(ctx, pipeline interface{}, opts ...interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	varargs := append([]interface{}{ctx, pipeline}, opts...)
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Watch", reflect.TypeOf((*MockDatabase)(nil).Watch), varargs...)
}

// WrappedDatabase mocks base method.
func (m *MockDatabase) WrappedDatabase() *mongo.Database {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WrappedDatabase")
	ret0, _ := ret[0].(*mongo.Database)
	return ret0
}

// WrappedDatabase indicates an expected call of WrappedDatabase.
func (mr *MockDatabaseMockRecorder) WrappedDatabase() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WrappedDatabase", reflect.TypeOf((*MockDatabase)(nil).WrappedDatabase))
}

// WriteConcern mocks base method.
func (m *MockDatabase) WriteConcern() *writeconcern.WriteConcern {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "WriteConcern")
	ret0, _ := ret[0].(*writeconcern.WriteConcern)
	return ret0
}

// WriteConcern indicates an expected call of WriteConcern.
func (mr *MockDatabaseMockRecorder) WriteConcern() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "WriteConcern", reflect.TypeOf((*MockDatabase)(nil).WriteConcern))
}
